//Code generated by protoc-gen-server. DO NOT EDIT.
package example

import (
    "context"
    "io"

    "github.com/Nais777/gserve/example"
    "github.com/golang/protobuf/ptypes/empty"

    "google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type grpcError interface {
    Code() codes.Code
}

func returnGRPCError(err error) error {
	if gerr, ok := err.(grpcError); ok {
		return status.Error(gerr.Code(), err.Error())
	}

	return status.Error(codes.Unknown, err.Error())
}

type UsersServer struct {
    svc UsersService
}

type UsersService interface {
    User(ctx context.Context, req *example.ID) (*example.User, error)
    Users(ctx context.Context, req *empty.Empty) (UserCursor, error)
    BatchUpdate(stream example.Users_BatchUpdateServer) error
    BeginBatchDelete(ctx context.Context) (BatchDeleter, error)
}

type UserCursor interface {
    Next() bool
    Current() *example.User
    Err() error
}

func (s UsersServer) User(ctx context.Context, req *example.ID) (*example.User, error) {
    resp, err := s.svc.User(ctx, req)
    if err != nil {
        return nil, returnGRPCError(err)
    }

    return resp, nil
}

func (s UsersServer) Users(req *empty.Empty, stream example.Users_UsersServer) error {
    c, err := s.svc.Users(stream.Context(), req)
    if err != nil {
        return returnGRPCError(err)
    }

    for c.Next() {
        o := c.Current()
        err := stream.Send(o)
        if err != nil {
            return returnGRPCError(err)
        }
    }

    if err := c.Err(); err != nil {
        return returnGRPCError(err)
    }

    return nil
}

func (s UsersServer) BatchUpdate(stream example.Users_BatchUpdateServer) error {
    err := s.svc.BatchUpdate(stream)
    if err != nil {
        return returnGRPCError(err)
    }

    return nil
}

type BatchDeleter interface {
    Next(*example.ID) error
    Complete() (*empty.Empty, error)
    Cancel()
}

func (s UsersServer) BatchDelete(stream example.Users_BatchDeleteServer) error {
    r, err := s.svc.BeginBatchDelete(stream.Context())
	if err != nil {
		return returnGRPCError(err)
	}
	defer r.Cancel()

	for {
		c, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return returnGRPCError(err)
		}

		err = r.Next(c)
		if err != nil {
			return returnGRPCError(err)
		}
	}

	resp, err := r.Complete()
	if err != nil {
		return returnGRPCError(err)
	}

	err = stream.SendAndClose(resp)
	if err != nil {
		return returnGRPCError(err)
	}

	return nil
}
